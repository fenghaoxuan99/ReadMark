


# 引用
引用就是给变量起别名。



## 引用的本质
C++中的引用可以理解为一个变量的别名，它的本质在底层实现上其实是一个==指针常量==也就是，一旦指向一个值，那这个指向就不能变。这就是为什么引用在声明时必须被初始化的原因。

尽管引用在语法层面上与普通的变量使用方式几乎相同，可以对其进行赋值等操作，但在底层实现上，这些操作都是通过指针间接完成的。当对引用进行操作时，编译器会自动将其转化为对指针所指向的对象的操作。

需要注意的是，尽管引用在底层实现上与指针有相似之处，但在C++的语法层面，引用和指针还是有明显的区别的。例如，引用总是指向一个有效的对象，没有空引用，而且引用一旦被初始化为指向一个对象，就不能再指向其他对象。这些特性使得引用在某些情况下比指针更为安全易用。
```cpp
// 定义变量 a
int a = 10;

// 定义变量 a 的引用 b
int& b = a;

int* const b = &a;
```
定义的是一个指针常量 , 该指针是常量 , 指针本身 也就是 指针指向的地址 不可更改



## 左值和右值
- 左值：有内存地址，可以通过地址访问（变量名、指针或者引用）
- 右值：没有内存地址。无法通过地址（变量名、指针或者引用）来访问

## 引用做函数的返回值
注意：不要返回局部变量的引用
其实也就是说，出了作用域生命周期会消失的，都不要返回去，这样会野指针，访问非法内存。
```cpp
#include<iostream>
using namespace std;
 
//函数返回值为引用，返回局部变量出现的问题
int& f1()
{
	int a = 5;
	return a;
}
 
//返回静态变量引用
int& f2()
{
	static int a = 5;
	return a;
}
 
int main()
{
	//引用：作函数返回值时，不要返回局部变量引用，函数调用可以作为左值。
 
	//测试调用函数 - 返回局部变量的引用 
	int& result = f1();
	cout << "返回局部变量引用 result = " << result << endl;
	cout << "返回局部变量引用 result = " << result << endl;
	cout << "返回局部变量引用 result 值异常" << endl;
 
	//测试返回静态变量引用
	int& result2 = f2();
	cout << "返回静态变量引用 result2 = " << result2 << endl;
	cout << "返回静态变量引用 result2 = " << result2 << endl;
	cout << "返回静态变量引用 result2 值正常" << endl;
 
	//返回引用作为左值
	f2() = 27;
	cout << "返回引用的函数作为左值 result2 = " << result2 << endl;
	cout << "返回引用的函数作为左值，修改了引用变量 result2 值" << endl;
 
	system("pause");
 
	return 0;
}
```