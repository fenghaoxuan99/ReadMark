

算法的时间复杂度是衡量算法运行时间随输入规模增长而变化的趋势，通常用大O符号（Big O notation）表示。它关注的是最坏情况下的时间增长率，忽略常数和低阶项，仅保留最高阶项。以下是详细说明和计算方法：

---

### **时间复杂度的概念**
1. **定义**：时间复杂度描述算法执行时间与输入规模（n）的关系，反映算法效率的理论增长率。
2. **目的**：比较不同算法的效率，预测大规模输入下的性能表现。
3. **核心思想**：
   - 忽略具体运行时间，关注增长趋势。
   - 用渐近上界（大O）表示最坏情况的时间消耗。

---

### **计算方法**
1. **步骤**：
   1. **确定输入规模n**：如数组长度、矩阵维度等。
   2. **找出基本操作**：执行次数最多的操作（如循环内的核心操作）。
   3. **计算执行次数**：将基本操作次数表示为n的函数T(n)。
   4. **简化表达式**：保留最高阶项，忽略系数和低阶项，得到大O表示。

2. **常见规则**：
   - **顺序结构**：时间复杂度相加，取最大值。
     ```plaintext
     O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
     ```
   - **循环结构**：循环次数 × 循环体内复杂度。
   - **分支结构**：取各分支中最大时间复杂度。
   - **递归算法**：使用递归树或主定理分析。

3. **示例分析**：
   - **单层循环**：O(n)
     ```c
     for (int i = 0; i < n; i++) { /* O(1)操作 */ }
     ```
   - **双重循环**：O(n²)
     ```c
     for (int i = 0; i < n; i++) {
         for (int j = 0; j < n; j++) { /* O(1)操作 */ }
     }
     ```
   - **对数复杂度**：O(log n)
     ```c
     int i = 1;
     while (i < n) { i *= 2; } // 循环次数为 log₂n
     ```
   - **递归调用**（如归并排序）：O(n log n)
     ```plaintext
     T(n) = 2T(n/2) + O(n) → 主定理得 O(n log n)
     ```

---

### **常见时间复杂度类型**
按效率从高到低排序：
1. **O(1)**：常数时间（如哈希表查找）。
2. **O(log n)**：对数时间（如二分查找）。
3. **O(n)**：线性时间（如遍历数组）。
4. **O(n log n)**：线性对数时间（如快速排序）。
5. **O(n²)**：平方时间（如冒泡排序）。
6. **O(2ⁿ)**：指数时间（如斐波那契递归）。
7. **O(n!)**：阶乘时间（如旅行商暴力解）。

---

### **注意事项**
1. **递归分析**：需明确递归深度和每层工作量（如斐波那契O(2ⁿ) vs 归并排序O(n log n)）。
2. **变量独立**：若存在多个变量（如n和m），时间复杂度可能为O(nm)。
3. **平均与最坏情况**：如快速排序最坏O(n²)，平均O(n log n)，需明确上下文。

---

### **总结**
时间复杂度通过大O表示法抽象出算法的最坏时间增长率，计算时需逐步分析代码结构，关注循环、递归等关键部分，最终简化表达式。掌握常见复杂度类型及其对应算法，能有效评估和选择高效解决方案。