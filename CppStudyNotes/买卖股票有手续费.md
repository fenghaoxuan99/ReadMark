class Solution
{
public:
    int maxProfit(vector<int> &prices, int fee)
    {
        int n = prices.size();
        int buy = prices[0] + fee;
        int profit = 0;
        for (int i = 1; i < n; ++i)
        {
            if (prices[i] + fee < buy)
            {
                buy = prices[i] + fee;
            }
            else if (prices[i] > buy)
            {
                profit += prices[i] - buy;
                buy = prices[i];
            }
        }
        return profit;
    }
};


# 关于 `buy = prices[i]` 这一步骤的深入分析

在股票买卖含手续费的问题中，`buy = prices[i]` 这一行代码的处理逻辑非常关键，它体现了算法优化手续费计算的巧妙思想。我来详细解析这一步骤：

## 上下文回顾
这段代码出现在卖出操作的条件分支中：
```cpp
else if (prices[i] > buy) {
    profit += prices[i] - buy;
    buy = prices[i];  // 重点分析这一行
}
```

## 这一步骤的核心目的
1. **避免重复计算手续费**：
   - 当我们在某天卖出股票后，如果立即在同一天以相同价格"买入"，实际上相当于没有真正买入
   - 这样设置可以让后续的价格比较自动跳过手续费的计算

2. **实现利润的连续累积**：
   - 如果后续价格继续上涨，我们可以直接累加差价部分
   - 不需要为这部分连续上涨的利润重复支付手续费

## 具体逻辑分析
当 `prices[i] > buy` 时：
1. 我们先计算利润：`profit += prices[i] - buy`
2. 然后将 `buy` 更新为当前价格 `prices[i]`（而不是 `prices[i] + fee`）

这样处理意味着：
- 我们已经"卖出"了股票，获得了利润
- 我们假装以当前价格"买回"股票（实际上没有真正买入）
- 如果明天价格更高，我们可以直接计算差价，而不需要再支付一次手续费

## 为什么这样是正确的？
考虑连续上涨的情况：
- 假设价格序列是 [1, 2, 3, 4]，手续费 fee=1
- 传统思路：在1买入(成本2=1+1)，在4卖出(利润=4-2=2)
- 本算法：在1买入(成本2)，在2卖出(利润0)，buy=2；在3卖出(利润1)，buy=3；在4卖出(利润1)；总利润=0+1+1=2
- 结果相同，但算法处理了所有可能的卖出点

## 示例说明
以 prices = [1,3,5,7], fee=1 为例：
1. 初始 buy = 1+1=2
2. i=1: 3 > 2 → profit=1, buy=3
3. i=2: 5 > 3 → profit=1+2=3, buy=5
4. i=3: 7 > 5 → profit=3+2=5, buy=7
最终利润=5

如果不这样处理，可能会重复计算手续费，导致利润计算错误。

## 数学证明
这种处理方式实际上等价于：
- 只在第一次买入时支付手续费
- 后续的买卖视为对同一笔投资的调整
- 最终利润 = 最高价 - 最低价 - 单次手续费

这正是题目要求的最优解。