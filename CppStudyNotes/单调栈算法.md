# 单调栈算法详解：单调递减栈

单调栈是一种特殊的栈数据结构，它的核心特征是栈中的元素始终保持某种单调性（递增或递减）。这里我将重点解释**单调递减栈**的概念和处理逻辑。

## 什么是单调递减栈？

### 定义
单调递减栈是指栈中的元素从栈底到栈顶保持**单调递减**的顺序。也就是说，对于栈中的任意两个相邻元素，下面的元素总是大于或等于上面的元素。

### 递减的含义
这里的"递减"指的是：
- **严格递减**：栈中每个元素都比它下面的元素小（即 `stack[i] > stack[i+1]`）
- **非严格递减**（也称为单调不增）：栈中每个元素都不比它下面的元素大（即 `stack[i] >= stack[i+1]`）

在大多数算法问题中，我们使用的是**非严格递减**的单调栈（允许相等元素）。

## 单调递减栈的处理逻辑

### 基本操作规则
1. **入栈条件**：
   - 新元素 ≤ 当前栈顶元素：直接入栈
   - 新元素 > 当前栈顶元素：需要弹出栈顶元素直到满足新元素 ≤ 栈顶元素的条件

2. **出栈时机**：
   - 当新元素比栈顶元素大时，栈顶元素找到了它的"下一个更大元素"，此时可以计算相关信息并弹出

### 算法步骤详解

1. **初始化**：
   ```cpp
   stack<int> st;  // 存储元素索引
   vector<int> result(T.size(), 0);  // 初始化结果数组
   ```

2. **遍历元素**：
   - 对于每个新元素 `T[i]`，与栈顶元素 `T[st.top()]` 比较

3. **三种处理情况**：
   - **情况1**：`T[i] < T[st.top()]`
     ```cpp
     st.push(i);  // 直接入栈，保持递减性
     ```
   - **情况2**：`T[i] == T[st.top()]`
     ```cpp
     st.push(i);  // 相等也可以入栈，保持非严格递减
     ```
   - **情况3**：`T[i] > T[st.top()]`
     ```cpp
     while (!st.empty() && T[i] > T[st.top()]) {
         result[st.top()] = i - st.top();  // 计算并记录结果
         st.pop();  // 弹出已处理的元素
     }
     st.push(i);  // 处理完后将当前元素入栈
     ```

## 为什么使用单调递减栈？

在"每日温度"这类问题中，我们需要为每个元素找到右侧第一个比它大的元素。单调递减栈的机制正好满足这一需求：

1. **栈中元素性质**：栈中存储的都是尚未找到"下一个更大元素"的元素的索引
2. **处理时机**：当遇到一个比栈顶元素大的温度时，意味着栈顶元素找到了它的解
3. **效率优势**：每个元素最多入栈和出栈一次，时间复杂度O(n)

## 示例演示

以温度序列 `[73, 74, 75, 71, 69, 72, 76, 73]` 为例：

```
步骤 栈状态(索引:温度)         当前元素        操作
0    []                        73(0)        push 0
1    [0:73]                    74(1)        74>73, pop 0, result[0]=1-0=1, push 1
2    [1:74]                    75(2)        75>74, pop 1, result[1]=2-1=1, push 2
3    [2:75]                    71(3)        71<75, push 3
4    [2:75,3:71]               69(4)        69<71, push 4
5    [2:75,3:71,4:69]          72(5)        72>69, pop 4, result[4]=5-4=1
                                72>71, pop 3, result[3]=5-3=2
                                72<75, push 5
6    [2:75,5:72]               76(6)        76>72, pop 5, result[5]=6-5=1
                                76>75, pop 2, result[2]=6-2=4
                                stack empty, push 6
7    [6:76]                    73(7)        73<76, push 7
```

最终结果：`[1, 1, 4, 2, 1, 1, 0, 0]`

## 关键理解点

1. **栈的单调性**：确保栈中元素从底到顶是递减的，这样遇到更大的元素时才能确定前面哪些元素找到了解
2. **索引存储**：存储索引而非值，方便计算天数差
3. **出栈即解答**：元素被弹出时，意味着它遇到了第一个比它大的元素
4. **未处理元素**：最后留在栈中的元素代表没有遇到更高温度，结果保持初始值0

单调递减栈的这种特性使其成为解决"下一个更大元素"类问题的高效工具。