
# 柱状图中最大矩形问题的单调栈解法详解

这道题目要求我们找到柱状图中最大的矩形面积。给出的解法使用了单调栈（Monotonic Stack）这一数据结构，下面我将详细解释这个算法的处理逻辑。

## 算法概述

这个解法的核心思想是：对于每一根柱子，找到它左右两边第一个比它矮的柱子，这样就能确定以当前柱子高度为高的最大矩形宽度。

## 代码结构解析

1. **初始化处理**：
   ```cpp
   heights.insert(heights.begin(), 0); // 数组头部加入元素0
   heights.push_back(0); // 数组尾部加入元素0
   ```
   - 在数组头部和尾部各添加一个高度为0的柱子，这样可以确保所有原始柱子都能被处理到
   - 头部的0可以避免空栈检查的麻烦
   - 尾部的0可以强制处理栈中剩余的所有柱子

2. **栈初始化**：
   ```cpp
   stack<int> st;
   st.push(0);
   ```
   - 初始化一个栈，用于存储柱子的索引（注意是索引而不是高度）
   - 首先将第一个柱子（索引0，高度0）压入栈

3. **主循环处理**：
   ```cpp
   for (int i = 1; i < heights.size(); i++) {
       // 三种情况处理
   }
   ```
   - 遍历每一根柱子（从索引1开始）

## 三种情况处理

### 情况一：当前柱子比栈顶柱子高
```cpp
if (heights[i] > heights[st.top()]) {
    st.push(i);
}
```
- 直接压入栈，因为当前柱子的右边界还未确定
- 这样保持了栈中柱子高度是单调递增的

### 情况二：当前柱子等于栈顶柱子高度
```cpp
else if (heights[i] == heights[st.top()]) {
    st.pop(); // 这个可以加，可以不加，效果一样，思路不同
    st.push(i);
}
```
- 可以选择弹出再压入，或者直接压入
- 弹出再压入的优点是计算宽度时更准确（使用最新的索引）
- 直接压入的优点是代码更简洁

### 情况三：当前柱子比栈顶柱子矮
```cpp
else {
    while (!st.empty() && heights[i] < heights[st.top()]) {
        int mid = st.top();
        st.pop();
        if (!st.empty()) {
            int left = st.top();
            int right = i;
            int w = right - left - 1;
            int h = heights[mid];
            result = max(result, w * h);
        }
    }
    st.push(i);
}
```
- 这是核心处理逻辑
- 当当前柱子比栈顶柱子矮时，说明找到了栈顶柱子的右边界
- 弹出栈顶柱子（mid），此时新的栈顶就是它的左边界
- 计算以mid柱子高度为高的矩形面积：
  - 宽度 = 右边界(right) - 左边界(left) - 1
  - 高度 = heights[mid]
- 更新最大面积result
- 最后将当前柱子压入栈

## 关键点说明

1. **单调栈的性质**：
   - 栈中保存的是柱子的索引，且对应的高度是单调递增的
   - 当遇到比栈顶矮的柱子时，就开始计算之前更高柱子的面积

2. **边界处理**：
   - 头部添加的0确保栈永远不会空
   - 尾部添加的0确保所有柱子都会被处理

3. **面积计算**：
   - 对于每个被弹出的柱子mid，它能形成的最大矩形的高就是它自身的高度
   - 宽度由左右第一个比它矮的柱子决定（left和right）

## 示例分析

假设输入heights = [2,1,5,6,2,3]，处理过程如下：

1. 修改后的heights = [0,2,1,5,6,2,3,0]
2. 初始栈 = [0(高度0)]
3. 处理过程：
   - i=1: 2>0，压入栈 [0,1]
   - i=2: 1<2，弹出1，计算面积2*1=2，压入2 [0,2]
   - i=3: 5>1，压入 [0,2,3]
   - i=4: 6>5，压入 [0,2,3,4]
   - i=5: 2<6，弹出4，计算6*1=6；2<5，弹出3，计算5*2=10；压入5 [0,2,5]
   - i=6: 3>2，压入 [0,2,5,6]
   - i=7: 0<3，弹出6，计算3*1=3；0<2，弹出5，计算2*4=8；0<1，弹出2，计算1*6=6；压入7 [0,7]
4. 最终最大面积为10

## 复杂度分析

- 时间复杂度：O(n)，每个元素最多入栈和出栈一次
- 空间复杂度：O(n)，最坏情况下栈需要存储所有元素

这个算法巧妙地利用了单调栈的性质，高效地找到了每个柱子的左右边界，从而计算出最大矩形面积。


# 单调栈解法正确性分析

这个算法的正确性确实需要深入理解，关键在于它如何通过单调栈的性质确保每次计算的都是**以某个柱子高度为高的最大矩形**。

## 核心思想

算法的本质是：**对于每个柱子，找到它左右两边第一个比它矮的柱子**，这样就能确定以该柱子高度为高的最大宽度。

## 为什么每次只考虑一个元素？

实际上，算法并不是"只考虑一个元素的左右大小"，而是通过单调栈的巧妙设计，**在弹出每个柱子时**，已经隐含地确定了它的左右边界：

1. **右边界**：当前遍历到的柱子`i`就是右边界（第一个比栈顶矮的柱子）
2. **左边界**：弹出栈顶后的新栈顶就是左边界（栈中前一个柱子）

## 单调栈的关键性质

1. **栈内高度单调递增**：从栈底到栈顶，柱子高度严格递增
   - 当`heights[i] > heights[st.top()]`时直接压入（保持单调性）
   - 当`heights[i] <= heights[st.top()]`时开始弹出计算

2. **边界确定时机**：
   - 只有当遇到比栈顶矮的柱子时，才会触发面积计算
   - 这时可以确定栈顶柱子的右边界就是当前柱子`i`
   - 左边界就是栈顶下面的那个柱子（因为栈是单调递增的）

## 正确性证明

考虑当`heights[i] < heights[st.top()]`时：

1. 被弹出的柱子`mid`：
   - 它的高度是`heights[mid]`
   - 它的右边界是`i`（第一个比它矮的柱子）
   - 它的左边界是新的`st.top()`（栈中前一个柱子，第一个比它矮的柱子）

2. 形成的矩形：
   - 宽度 = (右边界) - (左边界) - 1 = `(i) - (st.top()) - 1`
   - 高度 = `heights[mid]`
   - 这个矩形就是以`mid`柱子高度为高的最大可能矩形

## 为什么需要首尾补0？

1. **头部补0**：
   - 确保栈永远不为空，简化代码逻辑
   - 作为最左边的虚拟边界

2. **尾部补0**：
   - 强制处理栈中剩余的所有柱子
   - 作为最右边的虚拟边界

## 示例详解

以`heights = [2,1,5,6,2,3]`为例：

1. 修改后`heights = [0,2,1,5,6,2,3,0]`
2. 处理到i=5（值=2）时：
   - 栈状态：[0(0),2(1),3(5),4(6)]
   - 2 < 6 → 弹出4(6):
     - 左边界=3(5), 右边界=5(2)
     - 宽度=5-3-1=1, 高度=6 → 面积=6
   - 2 < 5 → 弹出3(5):
     - 左边界=2(1), 右边界=5(2)
     - 宽度=5-2-1=2, 高度=5 → 面积=10
   - 2 > 1 → 停止弹出，压入5(2)

## 为什么这样能保证找到最大矩形？

因为算法确保：
1. 每个柱子都会被压入栈一次
2. 每个柱子只有在确定它的右边界时才会被弹出
3. 弹出时一定能确定它的左边界
4. 这样所有可能的矩形都会被考虑到

## 与其他方法的对比

相比暴力解法（O(n²)），单调栈的优势在于：
- 利用栈的性质避免了重复计算
- 每个柱子只入栈和出栈一次
- 通过维护单调性，可以高效地找到边界

这个算法的精妙之处在于它通过单调栈在一次遍历中，隐式地记录了所有必要的边界信息，从而高效地计算出最大矩形面积。