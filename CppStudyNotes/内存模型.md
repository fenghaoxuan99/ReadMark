

# 内存模型
## 内存的五大分区
1. 堆区（heap）——由程序员分配和释放， 若程序员不释放，程序结束时一般由操作系统回收。注意它与数据结构中的堆是两回事
2. 栈区（stack）——由编译器自动分配释放 ，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈
3. 静态全局区
    1. 未初始化静态全局区 —— 静态变量，全局变量，没有初始化的存在此区
    2. 初始化的静态全局区 —— 静态变量、全局变量，赋过初值的存放在此区
4. 文字常量区——常量、字符串就是放在这里的。 程序结束后由系统释放
5. (程序)代码区——用于存放函数体的(二进制)代码
![alt text](../Image/memory.png)


![](../Image\内存区域.png)




## malloc(0)的问题
在C语言中malloc(0)的语法也是对的，而且确实也分配了内存，但是内存空间是0，这个看起来说法很奇怪，但是从操作系统的原理来解释就不奇怪了。

在内存管理中，内存中有栈和堆两个部分，栈有自己的机器指令，是一种先进后出的数据结构。
而malloc分配的内存是堆内存，由于堆没有自己的机器指令，所以要由自己编写算法来管理这片内存，通常的做法是用链表在每片被分配的内存前加个表头，里面存储了被分配内存的起始地址和大小。
malloc等函数返回的就是表头里的起始指针（这个地址是由一系列的算法得来的，而这些操作又是由编译器的底层为我们做的）

动态分配内存成功之后，就会返回一个有效的指针。而对于分配0空间来说，算法会得出一个可用内存的起始地址，但可用的空间为0，而操作系统一般不知道其终止地址，一般是根据占用大小来推出终止地址的。所以对malloc(0)返回的指针进行操作就是错误的。

==即使malloc(0)也要记得free掉，因为malloc还会额外分配内存来维护申请的空间，malloc(0)时并不是什么也不做==
