/*
 * @lc app=leetcode.cn id=123 lang=cpp
 *
 * [123] 买卖股票的最佳时机 III
 */
#include <vector>
using namespace std;
// @lc code=start
class Solution
{
public:
    int maxProfit(vector<int> &prices)
    {
        if (prices.size() == 0)
            return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
// @lc code=end
这是一个关于股票买卖问题的动态规划解法，我来详细解释一下这个dp数组初始化的逻辑。

### 问题背景
题目要求最多进行两次交易（买入和卖出算一次交易），求最大利润。我们需要考虑四种状态：
1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

### DP状态定义
这里使用了一个二维DP数组：
- `dp[i][j]` 表示第i天处于状态j时的最大利润
- j的取值有5种：
  - 0：没有操作
  - 1：第一次买入
  - 2：第一次卖出
  - 3：第二次买入
  - 4：第二次卖出

### 初始化的解释

1. `dp[0][0] = 0`：
   - 第0天没有操作，利润自然是0

2. `dp[0][1] = -prices[0]`：
   - 第0天第一次买入，利润是负的第0天的股价
   - 这是第一次买入的初始状态

3. `dp[0][2] = 0`：
   - 第0天不可能完成第一次卖出（因为还没买入）
   - 所以利润为0（可以理解为如果当天买入又卖出，利润为0）

4. `dp[0][3] = -prices[0]`：
   - 这是关键点！表示第0天进行第二次买入
   - 看起来不合理，因为还没完成第一次交易怎么能进行第二次交易？
   - 实际上这是为了处理"同一天完成第一次买卖并立即进行第二次买入"的情况
   - 相当于：买入(第一次) -> 卖出(第一次) -> 买入(第二次)，在同一天完成
   - 这样做的目的是为了不遗漏任何可能的交易路径

5. `dp[0][4] = 0`：
   - 第0天不可能完成第二次卖出
   - 利润为0

### 为什么需要`dp[0][3] = -prices[0]`？

这种初始化方式考虑了极端情况：即在第一天就完成第一次买卖并立即进行第二次买入。虽然这种情况在实际中可能没有意义，但在算法中我们需要考虑所有可能性，以确保不遗漏最优解。

举个例子：
- 如果股价序列是[3,5,0,0,3,1,4]
- 最优解可能是在第1天买入卖出，然后在第5天买入第6天卖出
- 如果不初始化`dp[0][3]`，就可能错过这种最优解

### 状态转移的理解

后续的状态转移方程确保了：
1. 第一次买入：可以从无操作状态转移来，或者保持之前的买入状态
2. 第一次卖出：可以从第一次买入状态转移来，或者保持之前的卖出状态
3. 第二次买入：可以从第一次卖出状态转移来，或者保持之前的第二次买入状态
4. 第二次卖出：可以从第二次买入状态转移来，或者保持之前的第二次卖出状态

这种初始化方式配合状态转移方程，能够覆盖所有可能的交易路径，包括：
- 只交易一次
- 交易两次
- 在同一天完成部分交易操作

### 总结

这种初始化方式虽然看起来有些违反直觉，但它是为了确保动态规划能够涵盖所有可能的交易路径，包括那些看起来不太合理的路径（如同一天完成多次交易）。在动态规划中，我们经常需要这样全面考虑所有可能性，以确保不遗漏最优解。

这种处理方式也体现了动态规划的一个特点：通过状态定义和转移方程来系统地覆盖所有可能性，而不是依赖直觉判断哪些情况可能或不可能发生。