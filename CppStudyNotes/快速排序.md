

快速排序是一种高效的排序算法，采用**分治法**策略，平均时间复杂度为 \(O(n \log n)\)。以下是其基本逻辑的详细说明：

---

### **1. 核心思想**
- **分治**：将数组分为两个子数组，分别排序后再合并。
- **基准（Pivot）**：选择一个元素作为基准，将数组划分为**小于基准**和**大于基准**的两部分。
- **递归**：对子数组递归执行相同操作，直到子数组长度为1或0（天然有序）。

---

### **2. 具体步骤**

#### **步骤1：选择基准（Pivot）**
- 常见选择方式：首元素、末元素、中间元素或随机元素。
- 优化策略：如三数取中法（选头、中、尾的中位数），避免最坏时间复杂度。

#### **步骤2：分区（Partition）**
将数组重新排列，使所有**小于基准**的元素位于左侧，**大于基准**的位于右侧。以**Lomuto分区方案**为例：
1. **初始化**：选末位元素为基准，定义指针 `i` 指向小于基准的最后一个位置。
2. **遍历数组**：从首元素到倒数第二个元素。
   - 若当前元素 ≤ 基准，`i` 右移，交换 `i` 与当前元素。
3. **放置基准**：将基准交换到 `i+1` 的位置，此时基准左侧均小，右侧均大。

**示例**：数组 `[3,6,2,1,8,5,4]`，选末位 `4` 为基准：
- 遍历后，`i` 停留在2（元素1的位置）。
- 交换基准到 `i+1` 处，得到 `[3,2,1,4,8,5,6]`。

#### **步骤3：递归排序**
- 对基准左侧 `[3,2,1]` 和右侧 `[8,5,6]` 递归执行上述步骤。

---

### **3. 时间复杂度**
- **最优/平均情况**：每次分区均匀，递归树高度为 \(\log n\)，每层操作 \(O(n)\)，总时间 \(O(n \log n)\)。
- **最坏情况**：数组已有序且总选极端基准，退化为 \(O(n^2)\)。随机选基准可避免。

---

### **4. 空间复杂度**
- **原地排序**：无需额外存储，但递归调用栈占用空间。
- **平均情况**：栈深 \(\log n\) → \(O(\log n)\)。
- **最坏情况**：栈深 \(n\) → \(O(n)\)。

---

### **5. 分区方案对比**
| **方案**       | **Lomuto**                     | **Hoare**                     |
|----------------|--------------------------------|--------------------------------|
| **基准选择**    | 通常选末元素                   | 通常选首元素                   |
| **指针移动**    | 单指针 `i` 标记分割点          | 双指针从两端向中间扫描         |
| **交换次数**    | 较多（可能交换相同元素）       | 较少（直接跳过已正确元素）     |
| **实现复杂度**  | 较简单                         | 较复杂                         |

---

### **6. 示例代码（Lomuto分区）**
```python
def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)  # 获取基准位置
        quick_sort(arr, low, pi - 1)    # 递归左子数组
        quick_sort(arr, pi + 1, high)   # 递归右子数组

def partition(arr, low, high):
    pivot = arr[high]    # 选末元素为基准
    i = low - 1          # 分割点指针
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]  # 放置基准到正确位置
    return i + 1
```

---

### **7. 关键点总结**
- **基准选择**：影响性能，随机化选择可优化平均表现。
- **分区逻辑**：确保元素被正确划分到基准两侧。
- **终止条件**：子数组长度为1或0时停止递归。

通过合理实现，快速排序在大多数场景下表现优异，是实践中最常用的排序算法之一。